- 支持 select、update、insert、replace、delete
- 作用
  - 告诉我们mysql如何使用索引
  - 联接查询的执行顺序
  - 查询扫描的数据行数
- 内容（参数）
  - ID列：数据为一组数字或 null ，表示执行select语句的顺序 / null值表示有其它2个SQL语句union的数据集
    - ID值相同，执行顺序由上至下
    - ID值越大优先级越高，越先被执行
  - SELECT_TYPE列
    - SIMPLE: 不包含子查询或是union操作的查询
    - PRIMARY: 查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY
    - SUBQUERY: select 列表中的子查询
    - DEPENDENT SUBQUERY: 依赖外部结果的子查询
    - UNION: union操作的第二个或是之后的查询的值为union
    - DEPENDENT UNION: 当union作为子查询时，第二或之后的查询select_type值
    - UNION RESULT: union产生的结果集
    - DERIVED: 出现在 FROM 子句中的子查询
  - TABLE列
    - 输出数据所在行的表名称
    - \<unionM,N>: 由ID为M，N查询union产生的结果集
    - \<derivedN>/\<subqueryN>: 由ID为N的查询产生的结果
  - PARTITIONS列
    - 对于分区表，显示查询的分区ID
    - 对于非分区表，显示为 NULL
  - TYPE列
    - system：const联接类型的一个特列，当查询的表只有一行时使用
    - const：表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式
    - eq_ref：唯一索引或是主键索引查找，对于每个索引键，表中只有一条记录与之匹配
    - ref：非唯一索引查找，返回匹配某个单独值的所有行
    - ref_or_null：类似于ref类型，但是附加了对 NULL值列的查询
    - index_merge：该联接类型表示使用了索引合并优化方法（5.6版本）
    - range：索引范围扫描，常见于 between、>、< 这样的范围查询条件
    - index：FULL index Scan 全索引扫描，同ALL的区别是，遍历的是索引树
    - ALL：效果最差的联接方式，FULL TABLE SCAN 全表扫描
  - Extra列
    - distinct：优化distinct操作，在找到第一匹配的元祖后，停止找同样值的操作。
    - Not exists：使用not exists优化查询
    - Using filesort：使用额外操作进行排序，通常会出现在order by或group by查询中
    - Using index：使用了覆盖索引进行查询
    - Using temporary：需要使用临时表处理查询，常见于排序、子查询、分组查询
    - Using where：需要在mysql服务器层使用 where 条件来过滤数据
    - select tables optimized away：直接通过索引来获得数据，不用访问表，效率高
  - POSSIBLE_KEYS列
    - 可能会使用到的索引，不一定会使用到
  - KEY列
    - 查询优化器优化查询实际所使用的索引
    - 如果没有可用的索引，则显示为 NULL
    - 如查询使用了覆盖索引，则该索引仅出现在 KEY 列中
  - KEY_LEN列
    - 表示索引字段的最大可能长度
    - 长度由字段定义计算而来，并非数据的实际长度
    - 覆盖索引a, b, c，如果使用到了a，b，且为utf8编码，显示为3*2=6
  - Ref列
    - 表示那些列或常量被用于查找索引列上的值
  - rows列
    - mysql通过索引统计信息，估算的所需读取的行数，不十分准确
  - Filtered列
    - 表示返回结果的行数占许读取行数的百分比，值越大越好
    - 参考值，依赖于统计信息
- 执行计划的限制
  * 无法展示存储过程、触发器、UDF对查询的影响
  * 无法使用 Explain 对存储过程进行分析
  * 早期版本只支持对 select 语句进行分析
